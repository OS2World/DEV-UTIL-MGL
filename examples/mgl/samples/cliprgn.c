/****************************************************************************
*
*                   SciTech Multi-platform Graphics Library
*
*  ========================================================================
*
*   Copyright (C) 1991-2004 SciTech Software, Inc. All rights reserved.
*
*   This file may be distributed and/or modified under the terms of the
*   GNU General Public License version 2.0 as published by the Free
*   Software Foundation and appearing in the file LICENSE.GPL included
*   in the packaging of this file.
*
*   Licensees holding a valid Commercial License for this product from
*   SciTech Software, Inc. may use this file in accordance with the
*   Commercial License Agreement provided with the Software.
*
*   This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING
*   THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
*   PURPOSE.
*
*   See http://www.scitechsoft.com/license/ for information about
*   the licensing options available and how to purchase a Commercial
*   License Agreement.
*
*   Contact license@scitechsoft.com if any conditions of this licensing
*   are not clear to you, or you have questions about licensing options.
*
*  ========================================================================
*
* Language:     ANSI C
* Environment:  Any
*
* Description:  Display a number of random rectangles with random
*               attributes clipping them with clip regions.
*
****************************************************************************/

#include <string.h>
#include "mglsamp.h"
#include "pattern.h"

#define IMAGE_NAME "frog-8.bmp"
#define IMAGE_NAME2 "doggie2.bmp"
#define MAX_LINES 35

#define logoByteWidth 41
static uchar logoMSB[] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xF8,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0x80,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xE0,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFE,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0x80,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xDF,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0x87,0x80,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0x03,0xC0,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0x01,0xE0,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x3F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFE,0x00,0xF0,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x3F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFC,0x00,0xF8,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x3F,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFC,0x01,0xF0,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xF8,0x03,0xF0,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x03,0xE0,0x00,0x00,0x00,0xFF,0xFC,0x7F,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x07,0xE0,0x00,0x00,0x00,0x7F,0xF0,0x1F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xE0,0x0F,0xC0,0x00,0x00,0x00,0x7F,0xC0,0x0F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xE0,0x0F,0x80,0x00,0x00,0x00,0x3F,0x00,0x01,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xC0,0x1F,0x80,0x00,0x00,0x00,0x1F,0x80,0x00,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x0D,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0x80,0x1F,0x00,0x00,0x00,0x00,0x0F,0xC0,0x00,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0x80,0x3F,0x00,0x00,0x00,0x00,0x07,0xF0,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x0E,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0x00,0x7E,0x00,0x00,0x00,0x00,0x03,0xF8,0x03,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x0E,0x7F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0x00,0x7C,0x00,0x00,0x00,0x00,0x01,0xFE,0x03,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x0E,0x7F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFE,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x06,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFC,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x07,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFC,0x01,0xF0,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x07,0x1F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x03,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x8F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x03,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x8F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x8F,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xE0,0x0F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x87,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xE0,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC7,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xC0,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC3,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0x80,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC1,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0x80,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xE1,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xE0,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFE,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFC,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFC,0x01,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x3F,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFE,0x03,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x3F,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x1F,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xC7,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x0F,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xEF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x0F,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x0F,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x07,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x03,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x01,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x01,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x07,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x01,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x1F,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7F,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x01,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x03,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x07,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x0F,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,
    0x00,0x1F,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0x1F,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0x3F,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0x3F,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0x7F,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0x7F,0xFE,0x07,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0xFF,0xFC,0x01,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0xFF,0xF8,0x01,0xFF,0xF8,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
    0x00,0xFF,0xF8,0x00,0xFF,0xFC,0x00,0x00,0x07,0xFF,0xF8,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x7F,0xFC,0x00,0x00,0x00,0x00,0x00,0x7F,0xF8,0x00,0x00,0x03,0xFF,0xC0,0x7F,0xF0,0x00,0x00,0x00,
    0x00,0xFF,0xF0,0x00,0xFF,0xFC,0x00,0x00,0x1F,0xFF,0xFC,0x00,0x00,0x3F,0xFC,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x03,0xFF,0xFF,0x80,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x00,0x03,0xFF,0xC1,0xFF,0xF8,0x00,0x00,0x00,
    0x00,0xFF,0xF0,0x00,0x7F,0xFC,0x00,0x00,0xFF,0xFF,0xFF,0x80,0x00,0x3F,0xFC,0x3F,0xFF,0xFF,0xFF,0xFC,0x00,0x0F,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xE0,0x00,0x03,0xFF,0xC7,0xFF,0xFF,0x00,0x00,0x00,
    0x00,0xFF,0xF0,0x00,0x3F,0xF8,0x00,0x03,0xFF,0xFF,0xFF,0xE0,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x00,0x03,0xFF,0xCF,0xFF,0xFF,0xC0,0x00,0x00,
    0x00,0xFF,0xF0,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xF0,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x7F,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFC,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x00,
    0x00,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFC,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,
    0x00,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFC,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0x80,0x03,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,
    0x00,0xFF,0xFC,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,
    0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,
    0x00,0x7F,0xFF,0x80,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xF0,0x03,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,
    0x00,0x3F,0xFF,0xF8,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xF8,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
    0x00,0x3F,0xFF,0xFF,0x00,0x00,0x03,0xFF,0xFF,0x80,0xFF,0xFF,0xE0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x3F,0xFF,0xF8,0x3F,0xFF,0xF8,0x00,0x3F,0xFF,0xFE,0x7F,0xFF,0xF8,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
    0x00,0x3F,0xFF,0xFF,0xC0,0x00,0x03,0xFF,0xFE,0x00,0x3F,0xFF,0xE0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x7F,0xFF,0xE0,0x0F,0xFF,0xFC,0x00,0x7F,0xFF,0xE0,0x0F,0xFF,0xFC,0x03,0xFF,0xFF,0x81,0xFF,0xFF,0x00,0x00,
    0x00,0x1F,0xFF,0xFF,0xF0,0x00,0x07,0xFF,0xF8,0x00,0x0F,0xFF,0xF0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x7F,0xFF,0x00,0x01,0xFF,0xFC,0x00,0x7F,0xFF,0x80,0x03,0xFF,0xFE,0x03,0xFF,0xFC,0x00,0x3F,0xFF,0x80,0x00,
    0x00,0x0F,0xFF,0xFF,0xFC,0x00,0x07,0xFF,0xE0,0x00,0x07,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0xFF,0xFE,0x00,0x00,0x7F,0xFE,0x00,0xFF,0xFE,0x00,0x00,0xFF,0xFE,0x03,0xFF,0xF8,0x00,0x1F,0xFF,0x80,0x00,
    0x00,0x07,0xFF,0xFF,0xFE,0x00,0x07,0xFF,0xE0,0x00,0x03,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0xFF,0xFC,0x00,0x00,0x7F,0xFE,0x00,0xFF,0xFC,0x00,0x00,0x7F,0xFF,0x03,0xFF,0xF0,0x00,0x0F,0xFF,0x80,0x00,
    0x00,0x03,0xFF,0xFF,0xFF,0x80,0x0F,0xFF,0xC0,0x00,0x01,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x01,0xFF,0xF0,0x00,0x00,0x1F,0xFE,0x01,0xFF,0xF8,0x00,0x00,0x3F,0xFF,0x03,0xFF,0xF0,0x00,0x0F,0xFF,0xC0,0x00,
    0x00,0x01,0xFF,0xFF,0xFF,0xC0,0x0F,0xFF,0x80,0x00,0x00,0xFF,0xF0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x01,0xFF,0xF0,0x00,0x00,0x1F,0xFF,0x01,0xFF,0xF0,0x00,0x00,0x3F,0xFF,0x03,0xFF,0xE0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x7F,0xFF,0xFF,0xE0,0x1F,0xFF,0x80,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x01,0xFF,0xE0,0x00,0x00,0x0F,0xFF,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x03,0xFF,0xE0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x1F,0xFF,0xFF,0xF0,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xE0,0x00,0x00,0x0F,0xFF,0x01,0xFF,0xE0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x03,0xFF,0xFF,0xF0,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xE0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x7F,0xFF,0xF8,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x1F,0xFF,0xF8,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x07,0xFF,0xFC,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x01,0xFF,0xFC,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0xFF,0xFE,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0x7F,0xFE,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0x3F,0xFE,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0x3F,0xFE,0x1F,0xFE,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xC0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0x1F,0xFE,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xE0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x00,0x00,0x1F,0xFE,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,0xFF,0xE0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x07,0xFF,0xC0,0x00,0x1F,0xFE,0x1F,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xE0,0x00,0x00,0x00,0x00,0x01,0xFF,0xE0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x07,0xFF,0xC0,0x00,0x1F,0xFE,0x0F,0xFF,0x80,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x03,0xFF,0xF0,0x00,0x00,0x00,0x00,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x07,0xFF,0xE0,0x00,0x3F,0xFE,0x0F,0xFF,0xC0,0x00,0x00,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x07,0xFF,0xE0,0x00,0x3F,0xFE,0x07,0xFF,0xE0,0x00,0x01,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x01,0xFF,0xF8,0x00,0x00,0x00,0x00,0x01,0xFF,0xF8,0x00,0x00,0x3F,0xFF,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x03,0xFF,0xE0,0x00,0x3F,0xFE,0x07,0xFF,0xF0,0x00,0x03,0xFF,0xF8,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0xFF,0xFC,0x00,0x00,0x7F,0xFE,0x00,0xFF,0xFC,0x00,0x00,0x7F,0xFF,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x03,0xFF,0xF0,0x00,0x7F,0xFC,0x07,0xFF,0xF8,0x00,0x07,0xFF,0xF0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0xFF,0xFE,0x00,0x00,0x7F,0xFE,0x00,0xFF,0xFE,0x00,0x00,0xFF,0xFE,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x03,0xFF,0xFC,0x01,0xFF,0xFC,0x03,0xFF,0xFE,0x00,0x1F,0xFF,0xF0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x7F,0xFF,0x80,0x01,0xFF,0xFC,0x00,0x7F,0xFF,0x80,0x01,0xFF,0xFE,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x01,0xFF,0xFF,0x07,0xFF,0xFC,0x01,0xFF,0xFF,0x80,0xFF,0xFF,0xE0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x7F,0xFF,0xE0,0x0F,0xFF,0xFC,0x00,0x7F,0xFF,0xF0,0x0F,0xFF,0xFC,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x01,0xFF,0xFF,0xFF,0xFF,0xF8,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xFC,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF8,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0x80,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x7F,0xFF,0xFF,0xFF,0xE0,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xE0,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x3F,0xFF,0xFF,0xFF,0xE0,0x00,0x1F,0xFF,0xFF,0xFF,0xFE,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xC0,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x1F,0xFF,0xFF,0xFF,0xC0,0x00,0x0F,0xFF,0xFF,0xFF,0xFC,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xC0,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x0F,0xFF,0xFF,0xFF,0x80,0x00,0x07,0xFF,0xFF,0xFF,0xF8,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x07,0xFF,0xFF,0xFE,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xE0,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x7F,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFE,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x03,0xFF,0xFF,0xFC,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xC0,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x3F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x3F,0xFF,0xFF,0x00,0x00,0x3F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x0F,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xF0,0x00,0x03,0xFF,0xC0,0x00,0x07,0xFF,0xC0,0x00,
    0x00,0x00,0x1F,0xFF,0xC0,0x00,0x00,0x00,0x07,0xFF,0xFC,0x00,0x00,0x1F,0xFC,0x00,0x03,0xFF,0xC0,0x00,0x00,0x03,0xFF,0xFF,0x80,0x00,0x00,0x00,0x03,0xFF,0xFF,0xC0,0x00,0x03,0xFF,0xC0,0x00,0x03,0xFF,0xC0,0x00,
    0x00,0x00,0x07,0xFE,0x00,0x00,0x00,0x00,0x01,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFC,0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,
    0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,
    0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,
    0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x01,0xF0,0x00,0x00,0x3E,0x00,0x00,0x0F,0xE0,0x00,0x7F,0xC0,0x00,0x80,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x03,0xF8,0x00,0x01,0xFF,0x80,0x00,0x1F,0xE0,0x00,0x7F,0xC0,0x00,0xC0,0xC0,0xC0,0x00,0x0E,0x00,0x00,0x0F,0xF0,0x00,0x03,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x01,0xC0,0x60,0x00,0x01,0xFC,0x00,0x00,
    0x07,0x18,0x00,0x03,0x83,0xC0,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0xE0,0xE0,0xC0,0x00,0x0F,0x00,0x00,0x0E,0x9C,0x00,0x03,0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x01,0xC0,0x60,0x00,0x07,0xFF,0x00,0x00,
    0x07,0x08,0x00,0x03,0x00,0xE0,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x60,0xE0,0x80,0x00,0x0F,0x80,0x00,0x0C,0x0C,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x01,0xE0,0x60,0x00,0x07,0x07,0x00,0x00,
    0x07,0x00,0x00,0x06,0x00,0x60,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x61,0xE1,0x80,0x00,0x19,0x80,0x00,0x0C,0x0E,0x00,0x03,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x06,0x00,0x01,0xF0,0x60,0x00,0x0C,0x01,0x80,0x00,
    0x07,0x00,0x00,0x06,0x00,0x30,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x61,0xE1,0x80,0x00,0x19,0x80,0x00,0x0C,0x0E,0x00,0x03,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x06,0x00,0x01,0xB8,0x60,0x00,0x18,0x00,0x00,0x00,
    0x03,0xE0,0x00,0x06,0x00,0x30,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x63,0xF1,0x80,0x00,0x11,0xC0,0x00,0x0C,0x0E,0x00,0x03,0x00,0x00,0x00,0x00,0xF8,0x00,0x00,0x06,0x00,0x01,0xB8,0x60,0x00,0x18,0x00,0x00,0x00,
    0x00,0xF8,0x00,0x0C,0x00,0x30,0x00,0x1F,0xE0,0x00,0x06,0x00,0x00,0x73,0x33,0x80,0x00,0x30,0xC0,0x00,0x0C,0x1C,0x00,0x03,0xFC,0x00,0x00,0x01,0xFC,0x00,0x00,0x06,0x00,0x01,0x9C,0x60,0x00,0x18,0x00,0x00,0x00,
    0x00,0x38,0x00,0x0E,0x00,0x30,0x00,0x1F,0xE0,0x00,0x06,0x00,0x00,0x33,0x13,0x00,0x00,0x70,0xE0,0x00,0x0D,0xFC,0x00,0x03,0xFC,0x00,0x00,0x03,0xFE,0x00,0x00,0x06,0x00,0x01,0x8E,0x60,0x00,0x18,0x00,0x00,0x00,
    0x00,0x0C,0x00,0x06,0x00,0x30,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x33,0x13,0x00,0x00,0x7F,0xE0,0x00,0x0C,0xF0,0x00,0x03,0x00,0x00,0x00,0x01,0xFC,0x00,0x00,0x06,0x00,0x01,0x86,0x60,0x00,0x18,0x00,0x00,0x00,
    0x06,0x0C,0x00,0x07,0x00,0x60,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x1F,0x1B,0x00,0x00,0x60,0x70,0x00,0x0C,0xE0,0x00,0x03,0x00,0x00,0x00,0x00,0xF8,0x00,0x00,0x06,0x00,0x01,0x83,0x60,0x00,0x18,0x00,0x00,0x00,
    0x06,0x0C,0x00,0x07,0x00,0xE0,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x1E,0x1E,0x00,0x00,0xC0,0x70,0x00,0x0C,0x70,0x00,0x03,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x06,0x00,0x01,0x83,0xE0,0x00,0x1C,0x00,0x80,0x00,
    0x07,0x18,0x00,0x03,0xC1,0xC0,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x1E,0x1E,0x00,0x00,0xC0,0x30,0x00,0x0C,0x30,0x00,0x03,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x06,0x00,0x01,0x81,0xE0,0x00,0x0E,0x03,0x80,0x00,
    0x03,0xF8,0x00,0x01,0xFF,0x80,0x00,0x1C,0x00,0x00,0x06,0x00,0x00,0x1E,0x1E,0x00,0x01,0x80,0x18,0x00,0x0C,0x18,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x01,0x81,0xE0,0x00,0x07,0x07,0x00,0x00,
    0x01,0xF0,0x00,0x00,0x7F,0x00,0x00,0x0C,0x00,0x00,0x06,0x00,0x00,0x1C,0x0E,0x00,0x01,0x80,0x18,0x00,0x0C,0x1C,0x00,0x03,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x01,0x80,0xE0,0x00,0x07,0xFE,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x60,0x00,0x00,0xF8,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    };
static int logoHeight = sizeof(logoMSB)/logoByteWidth;

typedef struct {
    point_t p1,p2;
    point_t d1,d2;
    int color;
} vector;

/*----------------------------- Global Variables --------------------------*/

char demoName[] = "cliprgn";

/*------------------------------ Implementation ---------------------------*/

ibool rectTest(MGLDC *dc, region_t *region)
{
    int     maxx,maxy,val;
    rect_t  r;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Rectangle Demonstration");
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setClipRegion(region);

    maxx = MGL_maxx();
    maxy = MGL_maxy();
    while (!checkEvent()) {
        r.left = MGL_random(maxx);
        r.right = MGL_random(maxx);
        r.top = MGL_random(maxy);
        r.bottom = MGL_random(maxy);

        /* Fix the rectangle so it is not empty */

        if (r.right < r.left)
            SWAP(r.left,r.right);
        if (r.bottom < r.top)
            SWAP(r.top,r.bottom);

        MGL_setColor(randomColor());
        MGL_setBackColor(randomColor());

        if ((val = MGL_random(3)) == 0) {
            MGL_setPenStyle(MGL_BITMAP_TRANSPARENT);
            MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
            MGL_usePenBitmapPattern(0);
            }
        else if (val == 1) {
            MGL_setPenStyle(MGL_BITMAP_OPAQUE);
            MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
            MGL_usePenBitmapPattern(0);
            }
        else {
            MGL_setPenStyle(MGL_BITMAP_SOLID);
            }

        MGL_fillRect(r);
        }
    defaultAttributes(dc);
    return (pause());
}

ibool lineTest(MGLDC *dc, region_t *region)
/****************************************************************************
*
* Function:     lineTest
* Parameters:   dc          - Display dc
*
* Description:  Draw solid lines and how andchange thier color.
*
****************************************************************************/
{
    int i,lines,maxx,maxy;
    vector *v;

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    lines = ((float)MAX_LINES/maxy)*maxy;

    v = (vector *)malloc(sizeof(vector)*lines);

    for(i=0;i<lines;i++) {
        v[i].p1.x = i*(maxx/MAX_LINES);
        v[i].p1.y = i*(maxy/MAX_LINES);
        v[i].p2.x = maxx - i*(maxx/MAX_LINES);
        v[i].p2.y = i*(maxy/MAX_LINES);
        v[i].d1.x = 1;
        v[i].d1.y = -1;
        v[i].d2.x = -1;
        v[i].d2.y = 1;
        v[i].color = randomColor();
    }

    /* Display title message at the top of the window. */
    mainWindow(dc,"Line Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    MGL_setBackColor(MGL_realColor(dc,MGL_LIGHTGRAY));
    MGL_clearViewport();
    MGL_setColor(MGL_realColor(dc,MGL_GREEN));
    MGL_drawRegion(0,0,region);
    MGL_setClipRegion(region);

    MGL_setPenStyle(MGL_BITMAP_SOLID);
    while (!checkEvent()) {
        for(i=0;i<lines;i++) {
            /* change the position of both vertices */
            v[i].p1.x += v[i].d1.x;
            v[i].p1.y += v[i].d1.y;
            v[i].p2.x += v[i].d2.x;
            v[i].p2.y += v[i].d2.y;

            /* change the direction of the first vertice */
            if (v[i].p1.x>maxx) v[i].d1.x = -1;
            if (v[i].p1.x<=0) v[i].d1.x = 1;
            if (v[i].p1.y>maxy) v[i].d1.y = -1;
            if (v[i].p1.y<=0) v[i].d1.y = 1;

            /* change the direction of the second vertice */
            if (v[i].p2.x>maxx) v[i].d2.x = -1;
            if (v[i].p2.x<=0) v[i].d2.x = 1;
            if (v[i].p2.y>maxy) v[i].d2.y = -1;
            if (v[i].p2.y<=0) v[i].d2.y = 1;

            MGL_setColor(v[i].color);
            MGL_line(v[i].p1,v[i].p2);
            }
        }

    free(v);
    defaultAttributes(dc);
    return (pause());
}

ibool pixelDemo(MGLDC *dc, region_t *region)
/****************************************************************************
*
* Function:     pixelDemo
* Parameters:   dc  - Device context
*
* Description:  Display a pattern of random dots on the screen and
*               pick them back up again.
*
****************************************************************************/
{
    int     seed = 1958;
    int     x,y,maxx,maxy;

    mainWindow(dc,"MGL_pixel Demonstration");
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setClipRegion(region);

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_srand(seed);        /* Seed random number gen with known value  */

    MGL_beginPixel();
    while (!checkEvent()) {
        x = 1 + MGL_random(maxx);       /* Generate a random location   */
        y = 1 + MGL_random(maxy);
        MGL_setColor(randomColor());
        MGL_pixelCoordFast(x,y);
        }
    MGL_endPixel();
    MGL_setColor(MGL_defaultColor());
    return(pause());
}

ibool sysBltDemo(MGLDC *dc, region_t *region)
{
    int width,height,depth;
    int x,y,maxx,maxy;
    palette_t pal[256];
    rect_t rect = {0,0,0,0};
    pixel_format_t pf;
    MGLDC *memdc;

    /* Display title message at the top of the window. */
    mainWindow(dc,"System BitBlt Demonstration");
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();

    MGL_setClipRegion(region);

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    if (MGL_getBitsPerPixel(dc) <= 8)
        MGL_setColor(2);
    else
        MGL_setColorRGB(0,255,0);
    MGL_drawRegion(0,0,region);

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create a memory device context. */
    if ((memdc = MGL_createMemoryDC(width,height,depth,&pf)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Load a bitmap into the memory device context. The palette gets
     * loaded into the memory device context as well.
     */
    if (!MGL_loadBitmapIntoDC(memdc,IMAGE_NAME,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    if (depth <= 8) {
        MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
        MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
        MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);
        }

    rect.right = width;
    rect.bottom = height;

    while (!checkEvent()) {
        x = MGL_random(maxx-width);
        y = MGL_random(maxy-height);
        /* Copy image from image in memory to the screen. */
        MGL_bitBlt(dc,memdc,rect,x,y,MGL_REPLACE_MODE);
        }

    /* Remove all device contexts from memory. */
    MGL_destroyDC(memdc);
    defaultAttributes(dc);
    return(pause());
}

ibool screenBltDemo(MGLDC *dc, region_t *region)
{
    int width,height,depth,maxx,maxy;
    palette_t pal[256];
    rect_t rect = {0,0,0,0};
    pixel_format_t pf;
    MGLDC *memdc;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Screen to Screen BitBlt Demonstration");
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();

    MGL_setClipRegion(region);

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    if (MGL_getBitsPerPixel(dc) <= 8)
        MGL_setColor(2);
    else
        MGL_setColorRGB(0,255,0);
    MGL_drawRegion(0,0,region);

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create a memory device context. */
    if ((memdc = MGL_createMemoryDC(width,height,depth,&pf)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Load a bitmap into the memory device context. The palette gets
     * loaded into the memory device context as well.
     */
    if (!MGL_loadBitmapIntoDC(memdc,IMAGE_NAME,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    if (depth <= 8) {
        MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
        MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
        MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);
        }

    rect.right = width;
    rect.bottom = height;
    /* Copy image from image in memory to the screen. */
    MGL_bitBlt(dc,memdc,rect,50,50,MGL_REPLACE_MODE);

    MGL_bitBlt(dc,dc,rect,127,200,MGL_REPLACE_MODE);
    MGL_bitBlt(dc,dc,rect,408,100,MGL_REPLACE_MODE);
    MGL_bitBlt(dc,dc,rect,190,325,MGL_REPLACE_MODE);
    MGL_bitBlt(dc,dc,rect,280,0,MGL_REPLACE_MODE);

    /* Remove all device contexts from memory. */
    MGL_destroyDC(memdc);
    defaultAttributes(dc);
    return(pause());
}

ibool offScreenBltDemo(MGLDC *dc, region_t *region)
{
    int x,y,width,height,depth,maxx,maxy;
    palette_t pal[256];
    rect_t rect = {0,0,0,0};
    pixel_format_t pf;
    MGLDC *offdc;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Offscreen BitBlt Demonstration");
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setClipRegion(region);

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    if (MGL_getBitsPerPixel(dc) <= 8)
        MGL_setColor(2);
    else
        MGL_setColorRGB(0,255,0);
    MGL_drawRegion(0,0,region);

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create an offscreen device context for bitmap. */
    if ((offdc = MGL_createOffscreenDC(dc,width,height)) == NULL) {
        if (MGL_result() != grNoOffscreenMem)
            MGL_fatalError(MGL_errorMsg(MGL_result()));
        mainWindow(dc,"Offscreen memory not available. Press any key to continue");
        return pause();
        }

    /* Load a bitmap into the memory device context. The palette gets
     * loaded into the memory device context as well.
     */
    if (!MGL_loadBitmapIntoDC(offdc,IMAGE_NAME,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    if (depth <= 8) {
        MGL_getPalette(offdc,pal,MGL_getPaletteSize(offdc),0);
        MGL_setPalette(dc,pal,MGL_getPaletteSize(offdc),0);
        MGL_realizePalette(dc,MGL_getPaletteSize(offdc),0,true);
        }

    rect.right = width;
    rect.bottom = height;

    while (!checkEvent()) {
        x = MGL_random(maxx-width);
        y = MGL_random(maxy-height);
        /* Copy image from image in memory to the screen. */
        MGL_bitBlt(dc,offdc,rect,x,y,MGL_REPLACE_MODE);
        }

    /* Remove all device contexts from memory. */
    MGL_destroyDC(offdc);
    defaultAttributes(dc);
    return(pause());
}

ibool srcBltDemo(MGLDC *dc, region_t *region)
{
    int width,height,depth;
    int x,y,maxx,maxy;
    palette_t pal[256];
    rect_t rect = {0,0,0,0};
    pixel_format_t pf;
    MGLDC *memdc;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Memory Source BitBlt Demonstration");
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();

    MGL_setClipRegion(region);

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    if (MGL_getBitsPerPixel(dc) <= 8)
        MGL_setColor(2);
    else
        MGL_setColorRGB(0,255,0);
    MGL_drawRegion(0,0,region);

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create a memory device context. */
    if ((memdc = MGL_createMemoryDC(width,height,depth,&pf)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Load a bitmap into the memory device context. The palette gets
     * loaded into the memory device context as well.
     */
    if (!MGL_loadBitmapIntoDC(memdc,IMAGE_NAME,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    if (depth <= 8) {
        MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
        MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
        MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);
        }

    rect.right = width;
    rect.bottom = height;

    while (!checkEvent()) {
        x = MGL_random(maxx-width);
        y = MGL_random(maxy-height);
        /* Copy image from image in memory to the screen. */
        MGL_bitBlt(dc,memdc,rect,x,y,MGL_REPLACE_MODE);
        }

    /* Remove all device contexts from memory. */
    MGL_destroyDC(memdc);
    defaultAttributes(dc);
    return(pause());
}

ibool srcTranslationBltDemo(MGLDC *dc, region_t *region)
{
    int width,height,depth;
    int x,y,maxx,maxy;
    rect_t rect = {0,0,0,0};
    pixel_format_t pf;
    MGLDC *memdc;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Memory Source Translated BitBlt Demonstration");
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();

    MGL_setClipRegion(region);

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    if (MGL_getBitsPerPixel(dc) <= 8)
        MGL_setColor(2);
    else
        MGL_setColorRGB(0,255,0);
    MGL_drawRegion(0,0,region);

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create a memory device context. */
    if ((memdc = MGL_createMemoryDC(width,height,depth,&pf)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Load a bitmap into the memory device context. The palette gets
     * loaded into the memory device context as well.
     */
    if (!MGL_loadBitmapIntoDC(memdc,IMAGE_NAME,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));
    MGL_setDefaultPalette(dc);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

    rect.right = width-50;
    rect.bottom = height-50;

    while (!checkEvent()) {
        x = MGL_random(maxx-width);
        y = MGL_random(maxy-height);
        /* Copy image from image in memory to the screen. */
        MGL_bitBlt(dc,memdc,rect,x,y,MGL_REPLACE_MODE);
        }

    /* Remove all device contexts from memory. */
    MGL_destroyDC(memdc);
    defaultAttributes(dc);
    return(pause());
}

ibool dstBltDemo(MGLDC *dc, region_t *region)
{
    int width,height,depth;
    int maxx,maxy;
    rect_t rect = {0,0,0,0};
    pixel_format_t pf;
    MGLDC *memdc;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Memory Destination BitBlt Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create a memory device context compatible with display. */
    MGL_getPixelFormat(dc,&pf);
    if ((memdc = MGL_createMemoryDC(maxx+1,maxy+1,MGL_getBitsPerPixel(dc),&pf)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));
    MGL_setDefaultPalette(memdc);
    MGL_realizePalette(memdc,MGL_getPaletteSize(memdc),0,true);

    /* Load a bitmap onto the screen device context. The palette gets
     * loaded into the memory device context as well.
     */
    if (!MGL_loadBitmapIntoDC(dc,IMAGE_NAME,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    MGL_makeCurrentDC(memdc);

    /* Fill memDC with solid color */
    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setClipRegionDC(memdc,region);

    if (MGL_getBitsPerPixel(memdc) <= 8)
        MGL_setColor(2);
    else
        MGL_setColorRGB(0,255,0);
    MGL_drawRegion(0,0,region);

    MGL_makeCurrentDC(dc);

    rect.left = 0;
    rect.top = 0;
    rect.right = maxx+1;
    rect.bottom = maxy+1;
    /* Copy image from the screen to memory. */
    MGL_bitBlt(memdc,dc,rect,0,0,MGL_REPLACE_MODE);

    /* Reset Clipping Rectangle to entire viewport. */
    MGL_setClipRegionDC(memdc,MGL_rgnSolidRectCoord(0,0,maxx+1,maxy+1));

    /* Copy image from memory to the screen. */
    MGL_bitBlt(dc,memdc,rect,0,0,MGL_REPLACE_MODE);

    /* Remove all device contexts from memory. */
    MGL_destroyDC(memdc);
    defaultAttributes(dc);
    return(pause());
}

ibool dstTranslationBltDemo(MGLDC *dc, region_t *region)
{
    int width,height,depth;
    int maxx,maxy;
    rect_t rect = {0,0,0,0};
    pixel_format_t pf;
    MGLDC *memdc;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Memory Destination Translated BitBlt Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create a memory device context compatible with display. */
    MGL_getPixelFormat(dc,&pf);
    if ((memdc = MGL_createMemoryDC(maxx+1,maxy+1,MGL_getBitsPerPixel(dc),&pf)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));
    MGL_setDefaultPalette(memdc);
    MGL_realizePalette(memdc,MGL_getPaletteSize(memdc),0,true);

    /* Load a bitmap onto the screen device context. The palette gets
     * loaded into the memory device context as well.
     */
    if (!MGL_loadBitmapIntoDC(dc,IMAGE_NAME,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    MGL_makeCurrentDC(memdc);

    /* Fill memDC with solid color */
    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setClipRegionDC(memdc,region);

    if (MGL_getBitsPerPixel(memdc) <= 8)
        MGL_setColor(2);
    else
        MGL_setColorRGB(0,255,0);
    MGL_drawRegion(0,0,region);

    MGL_makeCurrentDC(dc);

    rect.left = 0;
    rect.top = 0;
    rect.right = maxx+1;
    rect.bottom = maxy+1;
    /* Copy image from the screen to memory. */
    MGL_bitBlt(memdc,dc,rect,0,0,MGL_REPLACE_MODE);

    /* Reset Clipping Rectangle to entire viewport. */
    MGL_setClipRegionDC(memdc,MGL_rgnSolidRectCoord(0,0,maxx+1,maxy+1));

    /* Copy image from memory to the screen. */
    MGL_bitBlt(dc,memdc,rect,0,0,MGL_REPLACE_MODE);

    /* Remove all device contexts from memory. */
    MGL_destroyDC(memdc);
    defaultAttributes(dc);
    return(pause());
}

ibool srcTransOffBltDemo(MGLDC *dc, region_t *region)
{
    int width,height,depth;
    int maxx,maxy;
    MGLDC *offdc;
    pixel_format_t pf;
    color_t transparent;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Source Transparency Offscreen Memory Accelerated Blit Demo");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create an offscreen device context for bitmap. */
    if ((offdc = MGL_createOffscreenDC(dc,width,height)) == NULL) {
        if (MGL_result() != grNoOffscreenMem)
            MGL_fatalError(MGL_errorMsg(MGL_result()));
        mainWindow(dc,"Offscreen memory not available. Press any key to continue");
        return pause();
        }

    /* Load a bitmap into the offscreen device context. The palette gets
     * realized as well.
     */
    if (!MGL_loadBitmapIntoDC(offdc,IMAGE_NAME2,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Get transparent color from pixel (0,0) */
    MGL_makeCurrentDC(offdc);
    transparent = MGL_getPixelCoord(0,0);
    MGL_makeCurrentDC(dc);
    MGL_setClipRegion(region);

    /* Copy image from offscreen video memory to the screen. */
    while (!checkEvent())
        MGL_srcTransBltCoord(dc,offdc,0,0,width,height,MGL_random(maxx+1),MGL_random(maxy+1),transparent,MGL_REPLACE_MODE);

    /* Remove all device contexts from memory. */
    MGL_destroyDC(offdc);
    defaultAttributes(dc);

    return(pause());
}

ibool dstTransOffBltDemo(MGLDC *dc, region_t *region)
{
    int width,height,depth;
    int maxx,maxy;
    MGLDC *offdc;
    pixel_format_t pf;
    color_t transparent;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Destination Transparency Offscreen Memory Accelerated Blit Demo");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create an offscreen device context compatible with display. */
    if ((offdc = MGL_createOffscreenDC(dc,maxx+1,maxy+1)) == NULL) {
        if (MGL_result() != grNoOffscreenMem)
            MGL_fatalError(MGL_errorMsg(MGL_result()));
        mainWindow(dc,"Offscreen memory not available. Press any key to continue");
        return pause();
        }

    MGL_makeCurrentDC(offdc);

    /* Fill offDC with solid color */
    MGL_setBackColor(MGL_realColor(dc,MGL_RED));
    MGL_fillRectCoord(0,0,maxx+1,maxy+1);

    /* Load a bitmap into the offscreen device context. The palette gets
     * realized as well.
     */
    if (!MGL_loadBitmapIntoDC(offdc,IMAGE_NAME2,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Get transparent color from pixel (0,0) */
    transparent = MGL_getPixelCoord(0,0);

    /* Clear display with transparent color key value (viewport area only). */
    MGL_makeCurrentDC(dc);
    MGL_setBackColor(transparent);
    MGL_clearViewport();

    MGL_setClipRegion(region);

    /* Copy image from offscreen video memory to the screen. */
    MGL_dstTransBltCoord(dc,offdc,0,0,maxx,maxy,0,0,transparent,MGL_REPLACE_MODE);

    /* Remove all device contexts from memory. */
    MGL_destroyDC(offdc);
    defaultAttributes(dc);
    return(pause());
}

ibool srcTransBltDemo(MGLDC *dc, region_t *region)
{
    int width,height,depth;
    int maxx,maxy;
    palette_t pal[256];
    MGLDC *memdc;
    pixel_format_t pf;
    color_t transparent;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Source Transparency Memory Accelerated Blit Demo");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create a memory device context compatible with display. */
    MGL_getPixelFormat(dc,&pf);
    if ((memdc = MGL_createMemoryDC(maxx+1,maxy+1,MGL_getBitsPerPixel(dc),&pf)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Load a bitmap into the memorty device context. The palette gets
     * realized as well.
     */
    if (!MGL_loadBitmapIntoDC(memdc,IMAGE_NAME2,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Get transparent color from pixel (0,0) */
    MGL_makeCurrentDC(memdc);
    transparent = MGL_getPixelCoord(0,0);
    MGL_makeCurrentDC(dc);
    MGL_setClipRegion(region);

    /* Set the display device context with the palette from the
     * memory device context.
     */
    if (depth <= 8) {
        MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
        MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
        MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);
        }

    /* Copy image from offscreen video memory to the screen. */
    while (!checkEvent())
        MGL_srcTransBltCoord(dc,memdc,0,0,width,height,MGL_random(maxx+1),MGL_random(maxy+1),transparent,MGL_REPLACE_MODE);

    /* Remove all device contexts from memory. */
    MGL_destroyDC(memdc);
    defaultAttributes(dc);
    return(pause());
}

ibool dstTransBltDemo(MGLDC *dc, region_t *region)
{
    int width,height,depth;
    int maxx,maxy;
    palette_t pal[256];
    MGLDC *memdc;
    pixel_format_t pf;
    color_t transparent;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Destination Transparency Memory Accelerated Blit Demo");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create a memory device context compatible with display. */
    MGL_getPixelFormat(dc,&pf);
    if ((memdc = MGL_createMemoryDC(maxx+1,maxy+1,MGL_getBitsPerPixel(dc),&pf)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));
    MGL_makeCurrentDC(memdc);

    /* Fill memdc with solid color */
    MGL_setBackColor(MGL_realColor(dc,MGL_RED));
    MGL_fillRectCoord(0,0,maxx+1,maxy+1);

    /* Load a bitmap into the offscreen device context. The palette gets
     * realized as well.
     */
    if (!MGL_loadBitmapIntoDC(memdc,IMAGE_NAME2,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Get transparent color from pixel (0,0) */
    transparent = MGL_getPixelCoord(0,0);

    /* Clear display with transparent color key value (viewport area only). */
    MGL_makeCurrentDC(dc);
    MGL_setBackColor(transparent);
    MGL_clearViewport();

    MGL_setClipRegion(region);

    /* Set the display device context with the palette from the
     * memory device context.
     */
    if (depth <= 8) {
        MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
        MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
        MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);
        }

    /* Copy image from offscreen video memory to the screen. */
    MGL_dstTransBltCoord(dc,memdc,0,0,maxx,maxy,0,0,transparent,MGL_REPLACE_MODE);

    /* Remove all device contexts from memory. */
    MGL_destroyDC(memdc);
    defaultAttributes(dc);
    return(pause());
}

ibool linBltDemo(MGLDC *dc, region_t *region)
{
    // TODO: Implement this!
#if 0
    int x,y,width,height,depth;
    int maxx,maxy;
    MGLDC *offdc;
    pixel_format_t pf;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Linear Offscreen Memory Accelerated Blit Demo");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    offdc = MGL_createLinearOffscreenDC();

    /* Load a bitmap into the offscreen device context. The palette gets
     * realized as well.
     */
    if (!MGL_loadBitmapIntoDC(offdc,IMAGE_NAME2,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    MGL_setClipRegion(region);

    /* Copy image from offscreen video memory to the screen. */
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_bitBltLinCoord(dc,offdc,0,dc->mi.bytesPerLine,x,y,x+width-1,y+height-1,MGL_REPLACE_MODE);
        }

    /* Remove all device contexts from memory. */
    MGL_destroyDC(offdc);
    defaultAttributes(dc);
    return(pause());
#else
    return true;
#endif

}

ibool srcTransLinBltDemo(MGLDC *dc, region_t *region)
{
    // TODO: Implement this!
#if 0
    int x,y,width,height,depth;
    int maxx,maxy;
    MGLDC *offdc;
    pixel_format_t pf;
    color_t transparent;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Source Transparency Linear Offscreen Memory Accelerated Blit Demo");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    offdc = MGL_createLinearOffscreenDC();
    /* Load a bitmap into the offscreen device context. The palette gets
     * realized as well.
     */
    if (!MGL_loadBitmapIntoDC(offdc,IMAGE_NAME2,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Get transparent color from pixel (0,0) */
    MGL_makeCurrentDC(offdc);
    transparent = MGL_getPixelCoord(0,0);
    MGL_makeCurrentDC(dc);

    MGL_setClipRegion(region);

    /* Copy image from offscreen video memory to the screen. */
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_srcTransBltLinCoord(dc,offdc,0,dc->mi.bytesPerLine,x,y,x+width-1,y+height-1,transparent,MGL_REPLACE_MODE);
        }

    /* Remove all device contexts from memory. */
    MGL_destroyDC(offdc);
    defaultAttributes(dc);
    return(pause());
#else
    return true;
#endif

}

ibool dstTransLinBltDemo(MGLDC *dc, region_t *region)
{
    // TODO: Implement this!
#if 0
    int width,height,depth;
    int maxx,maxy;
    palette_t pal[256];
    MGLDC *offdc;
    pixel_format_t pf;
    color_t transparent;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Destination Transparency Linear Offscreen Memory Accelerated Blit Demo");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME2,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    offdc = MGL_createLinearOffscreenDC();
    MGL_makeCurrentDC(offdc);

    /* Fill offdc with solid color */
    MGL_setBackColor(MGL_realColor(dc,MGL_RED));
    MGL_fillRectCoord(0,0,maxx+1,maxy+1);

    /* Load a bitmap into the offscreen device context. The palette gets
     * realized as well.
     */
    if (!MGL_loadBitmapIntoDC(offdc,IMAGE_NAME2,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Get transparent color from pixel (0,0) */
    transparent = MGL_getPixelCoord(0,0);

    MGL_makeCurrentDC(dc);
    MGL_setBackColor(transparent);
    MGL_clearDevice();
    MGL_setClipRegion(region);

    /* Set the display device context with the palette from the
     * memory device context.
     */
    if (depth <= 8) {
        MGL_getPalette(offdc,pal,MGL_getPaletteSize(offdc),0);
        MGL_setPalette(dc,pal,MGL_getPaletteSize(offdc),0);
        MGL_realizePalette(dc,MGL_getPaletteSize(offdc),0,true);
        }

    /* Copy image from offscreen video memory to the screen. */
    MGL_dstTransBltLinCoord(dc,offdc,0,dc->mi.bytesPerLine,0,0,width-1,height-1,transparent,MGL_REPLACE_MODE);

    /* Remove all device contexts from memory. */
    MGL_destroyDC(offdc);
    defaultAttributes(dc);
    return(pause());
#else
    return true;
#endif

}

ibool textDemo(MGLDC *dc, region_t *region)
{
    int         i,j,maxx;
    font_t      *font;
    char        buf[80];

    maxx = MGL_maxx();

    /* Load common bitmap font. If not present, just continue. */
    strcpy(buf,"helv38.fnt");
    font = MGL_loadFont(buf);
    err = MGL_result();
    if (err != grOK)
        return true;

    sprintf(buf,"Bitmap Font: '%s' - %d Point", font->name, font->pointSize);
    mainWindow(dc,buf);
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setClipRegion(region);

    /* Display all characters on the screen */
    MGL_useFont(font);
    buf[1] = '\0';
    for (j = 0; j < 16; j++) {
        for (i = ' '; i < 256; i++) {
            buf[0] = i;
            MGL_drawStr(buf);
            if (MGL_getX() + MGL_maxCharWidth() > maxx) {
                MGL_moveToCoord(0,MGL_getY() + MGL_textHeight());
                }
            }
        }

    /* Unload the font from memory */
    MGL_unloadFont(font);
    MGL_useFont(defFont);
    defaultAttributes(dc);

    return(pause());
}

ibool textDemoVector(MGLDC *dc, region_t *region)
{
    int         i,j,maxx;
    font_t      *font;
    char        buf[80];

    maxx = MGL_maxx();

    /* Load common vector font. If not present, just continue. */
    strcpy(buf,"romanc.fnt");
    font = MGL_loadFont(buf);
    err = MGL_result();
    if (err != grOK)
        return true;

    sprintf(buf,"Vector Font: '%s'", font->name);
    mainWindow(dc,buf);
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setClipRegion(region);

    /* Display all characters on the screen */
    MGL_useFont(font);
    buf[1] = '\0';
    for (j = 0; j < 16; j++) {
        for (i = ' '; i < 128; i++) {
            buf[0] = i;
            MGL_drawStr(buf);
            if (MGL_getX() + MGL_maxCharWidth() > maxx) {
                MGL_moveToCoord(0,MGL_getY() + MGL_textHeight());
                }
            }
        }

    /* Unload the font from memory */
    MGL_unloadFont(font);
    MGL_useFont(defFont);
    defaultAttributes(dc);

    return(pause());
}

ibool textDemoTrueType(MGLDC *dc, region_t *region)
{
    int         i,j,maxx,pointSize = 24;
    font_t      *font;
	font_lib_t  *fontLib;
    char        buf[80];

    maxx = MGL_maxx();

    /* Load common TrueType font. If not present, just continue. */
    strcpy(buf,"truetype/flange-l.ttf");
    if ((fontLib = MGL_openFontLib(buf)) == NULL)
        return true;
    if ((font = MGL_loadFontInstance(fontLib,pointSize,0,0,true)) == NULL) {
        MGL_closeFontLib(fontLib);
        return true;
        }

	sprintf(buf,"TrueType Font Library: %s - %d Point", fontLib->name, font->pointSize);
    mainWindow(dc,buf);
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setClipRegion(region);

    /* Display all characters on the screen */
    MGL_useFont(font);
    MGL_setFontBlendMode(MGL_AA_RGBBLEND);
    if (MGL_getBitsPerPixel(dc) <= 8) {
        MGL_setFontAntiAliasPalette(
            MGL_rgbColor(dc, 255, 255, 255),
            MGL_rgbColor(dc, 192, 192, 192),
            MGL_rgbColor(dc, 128, 128, 128),
            MGL_rgbColor(dc, 64, 64, 64),
            MGL_rgbColor(dc, 0, 0, 0));
        }
    buf[1] = '\0';
    for (j = 0; j < 16; j++) {
        for (i = ' '; i < 128; i++) {
            buf[0] = i;
            MGL_drawStr(buf);
            if (MGL_getX() + MGL_maxCharWidth() > maxx) {
                MGL_moveToCoord(0,MGL_getY() + MGL_textHeight());
                }
            }
        }

    /* Unload the font from memory */
    MGL_unloadFont(font);
	MGL_closeFontLib(fontLib);
    MGL_useFont(defFont);
    defaultAttributes(dc);

    return(pause());
}

ibool monoImageDemo(MGLDC *dc, region_t *region)
{
    int i,x,y,maxx,maxy;

    /* Display title message at the top of the window. */
    mainWindow(dc,"Monochrome Image BltBlt Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setColor(MGL_realColor(dc,MGL_RED));
    MGL_drawRegion(0,0,region);
    MGL_setClipRegion(region);
    MGL_setColor(MGL_realColor(dc,MGL_GREEN));
    for (i = 0; i < 25; i++) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putMonoImage(dc,x,y,logoByteWidth<<3,logoByteWidth,logoHeight,(void *)&logoMSB);
        }

    defaultAttributes(dc);
    return(pause());
}

ibool bitmapDemo1(MGLDC *dc, region_t *region)
{
    int i,x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putBitmap (Monochrome Image) Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setClipRegion(region);

    /* Load a pcx and the palette from the image file. */
    if ((bitmap = (bitmap_t *)MGL_loadPNG("cow-1.png",true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Justify the image that will be put on the screen */
    x = (MGL_sizex(dc)-bitmap->width)/2;
    y = (MGL_sizey(dc)-bitmap->height)/2;

    MGL_setColor(MGL_realColor(dc,MGL_RED));
    MGL_drawRegion(0,0,region);
    MGL_setColor(MGL_realColor(dc,MGL_BLUE));

    /* Put the image onto the display device context. */
    for (i = 0; i < 10; i++) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putBitmap(dc,x,y,bitmap,MGL_REPLACE_MODE);
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

    /* Pause until the user hits a key or presses a mouse button. */
    while(!checkEvent()) {}
    /* Reset the Ddefault Palette */
    MGL_setDefaultPalette(dc);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapDemo2(MGLDC *dc, region_t *region)
{
    int x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putBitmap (Non-Monochrome Image) Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setClipRegion(region);

    /* Load a pcx and the palette from the image file. */
    if ((bitmap = (bitmap_t *)MGL_loadBitmap("frog.bmp",true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

    /* Justify the image that will be put on the screen */
    x = (MGL_sizex(dc)-bitmap->width)/2;
    y = (MGL_sizey(dc)-bitmap->height)/2;

    MGL_setColor(MGL_realColor(dc,MGL_RED));
    MGL_drawRegion(0,0,region);

    /* Put the image onto the display device context. */
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putBitmap(dc,x,y,bitmap,MGL_REPLACE_MODE);
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

    /* Pause until the user hits a key or presses a mouse button. */
    while(!checkEvent()) {}
    /* Reset the Ddefault Palette */
    MGL_setDefaultPalette(dc);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapDemo3(MGLDC *dc, region_t *region)
{
    int x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putBitmap (Translated Image) Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setClipRegion(region);

    /* Load a pcx and the palette from the image file. */
    if ((bitmap = (bitmap_t *)MGL_loadBitmap("frog.bmp",true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Justify the image that will be put on the screen */
    x = (MGL_sizex(dc)-bitmap->width)/2;
    y = (MGL_sizey(dc)-bitmap->height)/2;

    MGL_setColor(MGL_realColor(dc,MGL_RED));
    MGL_drawRegion(0,0,region);

    /* Put the image onto the display device context. */
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putBitmap(dc,x,y,bitmap,MGL_REPLACE_MODE);
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

    /* Pause until the user hits a key or presses a mouse button. */
    while(!checkEvent()) {}
    /* Reset the Ddefault Palette */
    MGL_setDefaultPalette(dc);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapSectionDemo(MGLDC *dc, region_t *region)
{
    int x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putBitmapSection Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();

    MGL_setClipRegion(region);

    /* Load a pcx and the palette from the image file. */
    if ((bitmap = (bitmap_t *)MGL_loadPCX("doggie2.pcx",true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

    /* Put the image onto the display device context. */
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putBitmapSection(dc,0,0,bitmap->width/2,bitmap->height/2,x,y,
            bitmap,MGL_REPLACE_MODE);
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);
    MGL_setDefaultPalette(dc);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

    /* Pause until the user hits a key or presses a mouse button. */
    return(pause());
}

ibool bitmapSectionDemo2(MGLDC *dc, region_t *region)
{
    int x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putBitmapSection Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();

    MGL_setClipRegion(region);

    /* Load a pcx and the palette from the image file. */
    if ((bitmap = (bitmap_t *)MGL_loadPCX("doggie2.pcx",true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Put the image onto the display device context. */
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putBitmapSection(dc,0,0,bitmap->width/2,bitmap->height/2,x,y,
            bitmap,MGL_REPLACE_MODE);
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

    /* Pause until the user hits a key or presses a mouse button. */
    return(pause());
}

ibool bitmapTransDemo(MGLDC *dc, region_t *region)
{
    int x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;
    color_t transparent;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putBitmapSrcTrans Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();

    /* Load a bitmap and the palette from the image file. */
    if ((bitmap = MGL_loadBitmap("frog.bmp",true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

    transparent = *((color_t*)bitmap->surface);

    MGL_setClipRegion(region);

    /* Put the image onto the display device context. */
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putBitmapSrcTrans(dc,x,y,bitmap,transparent,MGL_REPLACE_MODE);
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

    /* Pause until the user hits a key or presses a mouse button. */
    while(!checkEvent()) {}
    /* Reset the Ddefault Palette */
    MGL_setDefaultPalette(dc);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapTransDemo2(MGLDC *dc, region_t *region)
{
    int x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;
    color_t transparent;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putBitmapDstTrans Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Load a bitmap and the palette from the image file. */
    if ((bitmap = MGL_loadBitmap("frog.bmp",true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

    transparent = *((color_t*)bitmap->surface);
    MGL_setBackColor(transparent);
    MGL_clearViewport();

    MGL_setClipRegion(region);

    /* Put the image onto the display device context. */
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putBitmapDstTrans(dc,x,y,bitmap,transparent,MGL_REPLACE_MODE);
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

    /* Pause until the user hits a key or presses a mouse button. */
    while(!checkEvent()) {}
    /* Reset the Ddefault Palette */
    MGL_setDefaultPalette(dc);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapTransSectionDemo(MGLDC *dc, region_t *region)
{
    int x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;
    color_t transparent;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putBitmapSrcTransSection Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();

    MGL_setClipRegion(region);

    /* Load a pcx and the palette from the image file. */
    if ((bitmap = (bitmap_t *)MGL_loadPCX("doggie2.pcx",true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

    /* Get the transparent color from the bitmap's surface */
    transparent = *((color_t*)bitmap->surface);

    /* Put the image onto the display device context. */
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putBitmapSrcTransSection(dc,0,0,bitmap->width/2,
            bitmap->height/2,x,y,bitmap,transparent,MGL_REPLACE_MODE);
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

    /* Pause until the user hits a key or presses a mouse button. */
    while (!checkEvent()) {}
    /* Reset the Ddefault Palette */
    MGL_setDefaultPalette(dc);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapTransSectionDemo2(MGLDC *dc, region_t *region)
{
    int x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putBitmapDstTransSection Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Load a pcx and the palette from the image file. */
    if ((bitmap = (bitmap_t *)MGL_loadPCX("doggie2.pcx",true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();

    MGL_setClipRegion(region);

    /* Put the image onto the display device context. */
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putBitmapDstTransSection(dc,0,0,bitmap->width/2,
            bitmap->height/2,x,y,bitmap,MGL_realColor(dc,MGL_BLUE),MGL_REPLACE_MODE);
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

    /* Pause until the user hits a key or presses a mouse button. */
    while (!checkEvent()) {}
    /* Reset the Ddefault Palette */
    MGL_setDefaultPalette(dc);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);
    return(pause());
}

ibool bitmapMaskDemo(MGLDC *dc, region_t *region)
{
    int i,x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putBitmapMask Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Load a pcx from the image file. */
    if ((bitmap = (bitmap_t *)MGL_loadPNG("cow-1.png",false)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setColor(MGL_realColor(dc,MGL_RED));
    MGL_drawRegion(0,0,region);
    MGL_setClipRegion(region);
    for (i = 0; i < 25; i++) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putBitmapMask(dc,x,y,bitmap,MGL_realColor(dc,MGL_GREEN),MGL_REPLACE_MODE);
        }

    defaultAttributes(dc);
    return(pause());
}

ibool putIconDemo(MGLDC *dc, region_t *region)
{
    int x,y,maxx,maxy;
    icon_t *icon = NULL;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_putIcon Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Load the icon. */
    if ((icon = MGL_loadIcon("skull.ico",false)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setColor(MGL_realColor(dc,MGL_RED));
    MGL_drawRegion(0,0,region);
    MGL_setClipRegion(region);
    MGL_setColor(MGL_realColor(dc,MGL_GREEN));
    while (!checkEvent()) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        MGL_putIcon(dc,x,y,icon);
        }

    defaultAttributes(dc);
    return(pause());
}

ibool glyphDemo(MGLDC *dc, region_t *region)
{
    int i,x,y,maxx,maxy,idx;
    font_t *font = NULL;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_drawGlyph Demonstration");
    statusLine("Press any key to continue, ESC to Abort");
    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setColor(MGL_BLACK);
    MGL_drawRegion(0,0,region);
    MGL_setClipRegion(region);
    MGL_setColor(MGL_realColor(dc,MGL_RED));

    font = MGL_loadFont("mvglyph0.fnt");
    if (font == NULL)
        return true;

    MGL_useFont(font);
    maxx = MGL_maxx();
    maxy = MGL_maxy();

    for (i = 0; i < 1024; i++) {
        x = MGL_random(maxx+1);
        y = MGL_random(maxy+1);
        idx = MGL_random(16);
        MGL_drawGlyph(font,x,y,idx);
        }

    /* Unload the font from memory */
    MGL_useFont(defFont);
    MGL_unloadFont(font);

    defaultAttributes(dc);
    return(pause());

}

ibool ellipseDemo(MGLDC *dc, region_t *region)
{
    int maxx,maxy;
    rect_t  r;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_ellipse Demonstration");
    statusLine("Press any key to start random test, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setClipRegion(region);
    MGL_setPenStyle(MGL_BITMAP_SOLID);
    while (!checkEvent()) {
        r.left = MGL_random(maxx-100);
        r.top = MGL_random(maxy-100);
        r.right = r.left + MGL_random(100);
        r.bottom = r.top + MGL_random(100);
        MGL_setPenSize(MGL_random(4)+1,MGL_random(4)+1);

        MGL_setColor(randomColor());
        MGL_ellipse(r);
        }

    defaultAttributes(dc);
    return(pause());
}

ibool filledEllipseDemo(MGLDC *dc, region_t *region)
{
    int val,maxx,maxy;
    rect_t  r;

    /* Display title message at the top of the window. */
    mainWindow(dc,"MGL_fillEllipse Demonstration");
    statusLine("Press any key to start random test, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setClipRegion(region);
    MGL_setPenStyle(MGL_BITMAP_SOLID);
    while (!checkEvent()) {
        r.left = MGL_random(maxx-100);
        r.top = MGL_random(maxy-100);
        r.right = r.left + MGL_random(100);
        r.bottom = r.top + MGL_random(100);

        MGL_setColor(randomColor());
        MGL_setBackColor(randomColor());

        if ((val = MGL_random(5)) == 0) {
            MGL_setPenStyle(MGL_BITMAP_TRANSPARENT);
            MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
            MGL_usePenBitmapPattern(0);
            }
        else if (val == 1) {
            MGL_setPenStyle(MGL_BITMAP_OPAQUE);
            MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
            MGL_usePenBitmapPattern(0);
            }
        else {
            MGL_setPenStyle(MGL_BITMAP_SOLID);
            }
        MGL_fillEllipse(r);
        }

    defaultAttributes(dc);
    return(pause());
}

ibool ellipseArcDemo(MGLDC *dc, region_t *region)
{
    int     maxx,maxy,startAngle,endAngle;
    rect_t  r;

    mainWindow(dc,"MGL_ellipseArc Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setClipRegion(region);
    MGL_setPenStyle(MGL_BITMAP_SOLID);
    while (!checkEvent()) {
        r.left = MGL_random(maxx-100);
        r.top = MGL_random(maxy-100);
        r.right = r.left + MGL_random(100);
        r.bottom = r.top + MGL_random(100);
        startAngle = MGL_random(360);
        endAngle = MGL_random(360);
        MGL_setPenSize(MGL_random(4)+1,MGL_random(4)+1);

        MGL_setColor(randomColor());
        MGL_ellipseArc(r,startAngle,endAngle);
        }

    defaultAttributes(dc);
    return(pause());
}


ibool filledEllipseArcDemo(MGLDC *dc, region_t *region)
{
    int     val,maxx,maxy,startAngle,endAngle;
    rect_t  r;

    mainWindow(dc,"MGL_fillEllipseArc Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setClipRegion(region);
    MGL_setPenStyle(MGL_BITMAP_SOLID);
    while (!checkEvent()) {
        r.left = MGL_random(maxx-100);
        r.top = MGL_random(maxy-100);
        r.right = r.left + MGL_random(100);
        r.bottom = r.top + MGL_random(100);
        startAngle = MGL_random(360);
        endAngle = MGL_random(360);

        MGL_setColor(randomColor());
        MGL_setBackColor(randomColor());

        if ((val = MGL_random(5)) == 0) {
            MGL_setPenStyle(MGL_BITMAP_TRANSPARENT);
            MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
            MGL_usePenBitmapPattern(0);
            }
        else if (val == 1) {
            MGL_setPenStyle(MGL_BITMAP_OPAQUE);
            MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
            MGL_usePenBitmapPattern(0);
            }
        else {
            MGL_setPenStyle(MGL_BITMAP_SOLID);
            }
        MGL_fillEllipseArc(r,startAngle,endAngle);
        }

    defaultAttributes(dc);
    return(pause());
}

ibool fastPolyDemo(MGLDC *dc, region_t *region)
{
    int         maxx,maxy;
    fxpoint_t   poly[4];            /* Space to hold polygon data   */

    mainWindow(dc,"MGL_fillPolygonFast Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setClipRegion(region);
    MGL_setPenStyle(MGL_BITMAP_SOLID);
    while (!checkEvent()) {
        /* Define a random polygon */

        poly[0].x = MGL_randoml(MGL_TOFIX(maxx));
        poly[0].y = MGL_randoml(MGL_TOFIX(maxy));
        poly[1].x = MGL_randoml(MGL_TOFIX(maxx));
        poly[1].y = MGL_randoml(MGL_TOFIX(maxy));
        poly[2].x = MGL_randoml(MGL_TOFIX(maxx));
        poly[2].y = MGL_randoml(MGL_TOFIX(maxy));

        MGL_setColor(randomColor());
        MGL_fillPolygonFX(3,poly,sizeof(fxpoint_t),0,0);
        }

    defaultAttributes(dc);
    return pause();
}

#define MAXPTS 6       /* Maximum # of pts in polygon  */
ibool polyDemo(MGLDC *dc, region_t *region)
{
    int         i,maxx,maxy,val;
    fxpoint_t   poly[MAXPTS];           /* Space to hold polygon data   */

    mainWindow(dc,"MGL_fillPolygon Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    MGL_setClipRegion(region);
    MGL_setPenStyle(MGL_BITMAP_SOLID);
    while (!checkEvent()) {
        /* Define a random polygon */

        for (i = 0; i < MAXPTS; i++) {
            poly[i].x = MGL_randoml(MGL_TOFIX(maxx));
            poly[i].y = MGL_randoml(MGL_TOFIX(maxy));
            }

        MGL_setColor(randomColor());
        MGL_setBackColor(randomColor());

        if ((val = MGL_random(3)) == 0) {
            MGL_setPenStyle(MGL_BITMAP_TRANSPARENT);
            MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
            MGL_usePenBitmapPattern(0);
            }
        else if (val == 1) {
            MGL_setPenStyle(MGL_BITMAP_OPAQUE);
            MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
            MGL_usePenBitmapPattern(0);
            }
        else {
            MGL_setPenStyle(MGL_BITMAP_SOLID);
            }

        MGL_fillPolygonFX(MAXPTS,poly,sizeof(fxpoint_t),0,0);
        }

    defaultAttributes(dc);
    return pause();
}

ibool randomLineDemo(MGLDC *dc, region_t * region)
{
    int val,maxx,maxy;
    point_t p1,p2;

    maxx = MGL_maxx();
    maxy = MGL_maxy();

    /* Display new title message at the top of the window. */
    mainWindow(dc,"Random line Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    MGL_setClipRegion(region);
    MGL_setPenStyle(MGL_BITMAP_SOLID);
    while (!checkEvent()) {
        p1.x = MGL_random(maxx);
        p1.y = MGL_random(maxy);
        p2.x = MGL_random(maxx);
        p2.y = MGL_random(maxy);
        MGL_setColor(randomColor());
        MGL_setBackColor(randomColor());
        MGL_setPenSize(MGL_random(5)+1,MGL_random(5)+1);
        if ((val = MGL_random(5)) == 0) {
            MGL_setPenStyle(MGL_BITMAP_TRANSPARENT);
            MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
            MGL_usePenBitmapPattern(0);
            }
        else if (val == 1) {
            MGL_setPenStyle(MGL_BITMAP_OPAQUE);
            MGL_setPenBitmapPattern(0,&bitpat[MGL_random(NUMPATS)+1]);
            MGL_usePenBitmapPattern(0);
            }
        else {
            MGL_setPenStyle(MGL_BITMAP_SOLID);
            }
        MGL_line(p1,p2);
        }
    defaultAttributes(dc);
    return pause();
}

ibool stretchBitmapDemo(MGLDC *dc, region_t * region)
{
    int x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;

    mainWindow(dc,"MGL_stretchBitmap Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();
    x=maxx/2,y=maxy/2;

    MGL_setClipRegion(region);

    /* Load a bitmap and the palette from the image file. */
    if ((bitmap = MGL_loadBitmap(IMAGE_NAME,true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the bitmap */
    MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setColor(MGL_realColor(dc,MGL_RED));
    MGL_drawRegion(0,0,region);

    while ((x<maxx) && (y<maxy) && (!checkEvent())) {
        MGL_stretchBitmap(dc,maxx-x,maxy-y,x,y,bitmap,MGL_REPLACE_MODE);
        x += 1;
        y += 1;
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

    defaultAttributes(dc);
    return(pause());
}

ibool stretchBitmapSectionDemo(MGLDC *dc, region_t * region)
{
    int x,y,maxx,maxy;
    bitmap_t *bitmap = NULL;

    mainWindow(dc,"MGL_stretchBitmapSection Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();
    x=maxx/2,y=maxy/2;

    MGL_setClipRegion(region);

    /* Load a bitmap and the palette from the image file. */
    if ((bitmap = MGL_loadBitmap(IMAGE_NAME,true)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the bitmap */
    MGL_setPalette(dc,bitmap->pal,MGL_getPaletteSize(dc),0);
    MGL_realizePalette(dc,MGL_getPaletteSize(dc),0,true);

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setColor(MGL_realColor(dc,MGL_RED));
    MGL_drawRegion(0,0,region);

    while ((x<maxx) && (y<maxy) && (!checkEvent())) {
        MGL_stretchBitmapSection(dc,0,0,bitmap->width/2,bitmap->height/2,
            maxx-x,maxy-y,x,y,bitmap,MGL_REPLACE_MODE);
        x += 1;
        y += 1;
        }

    /* Remove all bitmaps from memory. */
    MGL_unloadBitmap(bitmap);

    defaultAttributes(dc);
    return(pause());
}

ibool stretchBltDemo(MGLDC *dc, region_t * region)
{
    MGLDC *memdc;
    int x,y,maxx,maxy;
    int width,height,depth;
    pixel_format_t pf;
    palette_t pal[256];

    mainWindow(dc,"MGL_stretchBlt (Memory DC) Demonstration");
    statusLine("Press any key to continue, ESC to Abort");

    maxx = MGL_maxx();
    maxy = MGL_maxy();
    x=maxx/2,y=maxy/2;

    /* Get image information */
    if (!MGL_getBitmapSize(IMAGE_NAME,&width,&height,&depth,&pf))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Create a memory device context. */
    if ((memdc = MGL_createMemoryDC(width,height,depth,&pf)) == NULL)
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Load a bitmap into the memory device context. The palette gets
     * loaded into the memory device context as well.
     */
    if (!MGL_loadBitmapIntoDC(memdc,IMAGE_NAME,0,0,true))
        MGL_fatalError(MGL_errorMsg(MGL_result()));

    /* Set the display device context with the palette from the
     * memory device context.
     */
    MGL_getPalette(memdc,pal,MGL_getPaletteSize(memdc),0);
    MGL_setPalette(dc,pal,MGL_getPaletteSize(memdc),0);
    MGL_realizePalette(dc,MGL_getPaletteSize(memdc),0,true);

    MGL_setClipRegion(region);

    MGL_setBackColor(MGL_realColor(dc,MGL_BLUE));
    MGL_clearViewport();
    MGL_setColor(MGL_realColor(dc,MGL_RED));
    MGL_drawRegion(0,0,region);

    /* Put the image onto the display device context. */
    while ((x<maxx) && (y<maxy) && (!checkEvent())) {
        MGL_stretchBltCoord(dc,memdc,0,0,width,height,maxx-x,maxy-y,x,y,MGL_REPLACE_MODE);
        x += 1;
        y += 1;
        }

    /* Remove all device contexts from memory. */
    MGL_destroyDC(memdc);

    defaultAttributes(dc);
    return(pause());
}

void demo(MGLDC *dc)
{
    region_t    *clipRgn,*region2;
    ibool       go = true;
    int         dx = (MGL_maxx() > 640) ? MGL_maxx() / 8 : 0;
    int         dy = (MGL_maxy() > 480) ? MGL_maxy() / 8 : 0;

    /* Create the clip region */
    clipRgn = MGL_rgnSolidRectCoord(50,50,300+dx,280+dy);
    region2 = MGL_rgnSolidRectCoord(200+dx,150+dy,440+dx+dx,440+dy+dy);
    MGL_unionRegion(clipRgn, region2);
    region2 = MGL_rgnSolidRectCoord(340+dx,50,610+dx+dx,280+dy);
    MGL_unionRegion(clipRgn, region2);

    if (go) go = rectTest(dc,clipRgn);
    if (go) go = lineTest(dc,clipRgn);
    if (go) go = pixelDemo(dc,clipRgn);
    if (go) go = sysBltDemo(dc,clipRgn);
    if (go) go = screenBltDemo(dc,clipRgn);
    if (go) go = offScreenBltDemo(dc,clipRgn);
    if (go) go = srcBltDemo(dc,clipRgn);
    if (go) go = srcTranslationBltDemo(dc,clipRgn);
    if (go) go = dstBltDemo(dc,clipRgn);
    if (go) go = dstTranslationBltDemo(dc,clipRgn);
    if (go) go = srcTransOffBltDemo(dc,clipRgn);
    if (go) go = dstTransOffBltDemo(dc,clipRgn);
    if (go) go = srcTransBltDemo(dc,clipRgn);
    if (go) go = dstTransBltDemo(dc,clipRgn);
    if (go) go = linBltDemo(dc,clipRgn);
    if (go) go = srcTransLinBltDemo(dc,clipRgn);
    if (go) go = dstTransLinBltDemo(dc,clipRgn);
    if (go) go = textDemo(dc,clipRgn);
    if (go) go = textDemoVector(dc,clipRgn);
    if (go) go = textDemoTrueType(dc,clipRgn);
    if (go) go = monoImageDemo(dc,clipRgn);
    if (go) go = bitmapDemo1(dc,clipRgn);
    if (go) go = bitmapDemo2(dc,clipRgn);
    if (go) go = bitmapDemo3(dc,clipRgn);
    if (go) go = bitmapSectionDemo(dc,clipRgn);
    if (go) go = bitmapSectionDemo2(dc,clipRgn);
    if (go) go = bitmapTransDemo(dc,clipRgn);
    if (go) go = bitmapTransDemo2(dc,clipRgn);
    if (go) go = bitmapTransSectionDemo(dc,clipRgn);
    if (go) go = bitmapTransSectionDemo2(dc,clipRgn);
    if (go) go = bitmapMaskDemo(dc,clipRgn);
    if (go) go = putIconDemo(dc,clipRgn);
    if (go) go = glyphDemo(dc,clipRgn);
    if (go) go = ellipseDemo(dc,clipRgn);
    if (go) go = filledEllipseDemo(dc,clipRgn);
    if (go) go = ellipseArcDemo(dc,clipRgn);
    if (go) go = filledEllipseArcDemo(dc,clipRgn);
    if (go) go = fastPolyDemo(dc,clipRgn);
    if (go) go = polyDemo(dc,clipRgn);
    if (go) go = randomLineDemo(dc,clipRgn);
    if (go) go = stretchBitmapDemo(dc,clipRgn);
    if (go) go = stretchBitmapSectionDemo(dc,clipRgn);
    if (go) go = stretchBltDemo(dc,clipRgn);
}

// TODO: Need to add code to test for UniCode text clipping!

// TODO: Need to add code to test 1bpp and 4bpp bitmap blitting with
//       clipping!
